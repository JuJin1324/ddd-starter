# ddd-starter

## 개념
### 도메인
> 먼저, 도메인이라는 것은 '영역'을 말한다. 그러니 비즈니스상에서 도메인이란 '업무의 집합'이라고 봐야한다.
> 예를 들어서 스타벅스는 '커피' 도메인이고, 버거킹은 '음식' 도메인이다.
> 서브 도메인이라고 해서 더 구체적으로 쪼갤 수도 있지만, 가장 큰 틀에서 도메인의 의미는 위와 같다고 보면 된다.  
> 
> 도메인을 쉽게 이해하기 위해 음식 주문 배달 애플리케이션을 만든다고 가정한다.  
> 음식 주문 배달 애플리케이션은 음식을 주문하는 고객, 주문받은 음식을 만들고 판매하는 음식점, 
> 완성된 음식을 배달하는 배달원, 해당 음식을 주문하고 결제하는데 이용되는 카드사 또는 은행이 필요하다.  
> 이들을 각각의 도메인이라 부를 수 있다.  
> 이렇게 애플리케이션을 구현하기 위해 필요한 업무들을 자세히 구분하면 좋은 애플리케이션을 만들 가능성이 높아진다.  
> 해당 업무에서 고객이 음식을 주문하는 과정, 주문받은 음식을 처리하는 과정, 조리된 음식을 배달하는 과정 등 
> 도메인 지식(Domain Knowledge)들을 서비스 계층에서 비즈니스 로직으로 구현해야 하는 것이다.  
> 즉, 도메인은 현실에서 접하는 업무의 한 영역들을 말한다.  

### 기존 개발의 문제점
> 데이터베이스 위주의 개발 (데이터베이스 모델링을 중요시)     
> 서비스에는 흐름제어 로직밖에 없고 비즈니스 규칙과 개념들은 SQL에 존재한다. 이렇게 비즈니스 로직과 저장 기술이 강하게 결합되어 있는 
> 구조인 경우, 저장소를 변경하기 쉽지 않다. 또한 성능 측면에서 성능을 데이터베이스에 의존하게 된다. 
> 이러면 데이터가 많아졌을 때 데이터베이스의 성능은 지속적으로 떨어지고 이를 최적화 하기 위해 데이터베이스 서버의 사양과 용량을 
> 계속 증가시키고 쿼리 튜닝에 몰두할 수 밖에 없다. 클라우드 인프라를 사용한 자동 스케일 아웃은 의미가 없어진다. 
> 정작 바쁜 것은 데이터베이스이기 때문에 어플리케이션을 아무리 스케일 아웃해봐야 효과는 미미하다.
> 
> 트랜잭션 스크립트 패턴   
> 서비스(Spring에서 사용되는 Service를 말함)에 모든 비즈니스 로직이 있고 비즈니스 절차에 따라 도메인 객체를 이용해 처리한다. 
> 도메인 객체는 단지 속성값만 이용되는 정보 묶음의 역할만 하게 된다. 서비스는 유스케이스 처리의 단위이고 대부분의 비즈니스 로직 처리가 
> 서비스에서 이뤄지므로 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 계속 생겨날 수 있고 이런한 점이 유지보수를 어렵게 한다. 
> 비즈니스 로직을 테스트하기 위해 Mocking을 해야하고 이는 테스트의 복잡성을 높이고 관리하기 어려운 테스트 코드를 발생시킨다.  
> 
> 도메인 모델 패턴  
> 도메인 객체가 속성뿐만 아니라 비즈니스 행위를 가지고 있어 책임을 수행하게 된다.
> 서비스의 책임들이 도메인으로 분산되기 때문에 서비스의 메서드는 단순해진다.
> 거대한 서비스 클래스 대신 각기 적절한 책임을 가진 여러 클래스로 구성되므로 이해하기 쉽고 관리 및 테스트하기 쉽다.
> 잘 정의된 도메인 모델은 코드양을 줄이고 재사용성도 높다.
> 도메인 모델 패턴은 도메인 주도 설계의 애그리거트 패턴을 적용할 수 있는 구조이다.

### 유비쿼터스 언어
> 특정 도메인에서 특정 용어가 해당 도메인에서의 의도를 명확히 반영하고, 도메인의 핵심 개념을 잘 전달할 수 있는 언어.  
> 모든 팀원이 특정 용어를 들었을 때 같은 것을 생각할 수 있는 명확하게 정의된 언어. 
> 같은 용어에 각자 다른 생각을 하거나 같은 것을 말하지만 용어가 다른 경우가 있으면 안된다.
> 도메인에서 사용하는 언어는 코드에 그대로 똑같이 반영되야 한다. 똑같이 반영되지 않으면 개발자는 해당 용어를 해석하고 이해해야하는 부담이 생긴다.
> 유비쿼터스 언어를 사용함으로써 코드의 가독성을 높여 코드를 분석하고 이해하는데 시간을 절약할 수 있다.
> 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.

### Bounded Context
> 도메인 영역의 경계  
> 바운디드 컨텍스트안에서는 유비쿼터스 언어를 사용해야한다.  
> 도메인 영역의 경계의 기준은 유비쿼터스 언어를 사용했을 때, 해당 용어의 개념이 달리지는 그 곳을 기준으로 경계를 나눈다. ex) 결제 컨텍스트, 배송 컨텍스트  
> 
> 고객이라는 도메인은 결제 도메인 입장에서는 신용카드 정보나 계좌 정보를 가진 **"결제자"**로서 사용되고 배송 도메인 입장에서는 상품을 받을 주소와 우편번호, 
> 전화번호를 소유한 **"수취자"**를 의미한다.  
> 도메인 모델은 특정한 컨텍스트 안에서 완전한 의미를 갖는다.  
> 바운디드 컨텍스트는 여러개의 서브 도메인으로 구성되고 하나의 서브 도메인은 한 바운디드 컨텍스트에 포함된다.  

### Context Map
> 컨텍스트 경계를 식별해 내고 이들간의 관계를 표현한 그림을 컨텍스트 맵(Context Map)이라 한다.  
> 컨텍스트간의 관계는 선으로 표현되고 U는 Upstream으로서 공급자, D는 Downstream으로서 수요자를 나타낸다. 즉 데이터가 흐르는 방향.  

### 참조사이트
> [도메인 주도 설계란? DDD란?](https://yoonbing9.tistory.com/121)

---

## 도메인 모델링
### 엔티티(Entity)
> 엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체이다.  
> 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다.  
> 식별자가 있기 때문에 데이터베이스로 추적가능하다  

### 값 객체(Value Object)
> 값객체는 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다.  
> <도메인 주도 설계 핵심>의 저자 반 버논은 값객체의 특성을 다음과 같이 정의한다.  
> * 도메인 내의 어떤 대상을 측정하고, 수량화하고, 설명한다.  
> * 관련 특징을 모은 필수 단위로 개념적 전체를 모델링한다.  
> * 측정이나 설명이 변경될 땐 완벽히 대체 가능하다.  
> * 다른 값과 등가성을 사용해 비교할 수 있다.  
> * 값 객체는 일단 생성되면 변경할 수 없다.
> 
> 그 밖에 특성  
> * 밸류 타입은 불변
> * 시스템이 성숙함에 따라 데이터 값을 객체로 대체
> * 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.
> * 정말 String으로 우편 번호를 표현할 수 있는가?
> * 항상 equals() 메서드를 오버라이드할 것을 권고한다.
> * equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java
> * VALUE OBJECT는 DTO가 아니다. - Martin Fowler

### 애그리거트(Aggregate)
> * 관련 객체를 하나로 묶은 군집(1~2개의 엔티티와, 값 객체, 표준타입(자바에서 enum)으로 구성)  
> * 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.
> * 이들 간에는 비즈니스 의존관계를 맺고 있으며 비즈니스 정합성을 맞출 필요가 있다. 따라서 애그리거트 단위가 트랜잭션의 기본 단위가 된다.
> * 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
> * 애그리거트는 응집력을 유지하고 애그리거트 간에는 느슨한 결합을 유지한다.
> * 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
> * 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
> * 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다.(대부분 애그리거트 루트만 엔티티이다. 그 밖의 엔티티가 존재하면, 정말 그 객체가 엔티티가 맞는지 의심해봐야한다. 
> 혹은 드물게 운영상 데이터 추적 혹은 성능상의 이유로 엔티티로 만들기도 한다.)

### 애그리거트 루트(Aggregate root)
> * 애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정함.
> * 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있다.(퍼사드 패턴과 유사)
> * 애그리거트간의 참조는 직접참조하지 않고 ID 참조를 한다.(그림에서 Order가 Buyer를 직접 참조하지 않고 BuyerID 로 참조하고 있다.)
> * 애그리거트는 단일 트랜잭션으로 일관성을 유지하지만 애그리거트간의 일관성이 필요하다면 도메인 이벤트를 통해 다른 애그리거트를 갱신해서 일관성을 유지한다.

### 리포지토리(Repository)
> * 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델
> * 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
> * 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.
> * 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException 과 같은 문제가 발생하게 된다.
> * 리포지토리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다.(애그리거트 1 개 당 리포지토리 1 개)

### 도메인 서비스
> 여러 애그리거트가 필요한 기능 ex) 결제 금액 계산 로직  
> 
> * 상품 애그리거트: 구매하는 상품의 가격이 필요하다. 또한 상품에 따라 배송비가 추가되기도 한다.
> * 주문 애그리거트: 상품별로 구매 개수가 필요하다.
> * 할인 쿠폰 애그리거트: 쿠폰별로 지정한 할인 금액이나 비율에 따라 주문 총 금액을 할인한다. 
> 할인 쿠폰을 조건에 따라 중복 사용할 수 있다거나 지정한 카테고리의 상품에만 적용할 수 있다는 제약 조건이 있다면 할인 계산이 복잡해진다.  
> * 회원 애그리거트: 회원 등급에 따라 추가 할인이 가능하다.
> 이 상황에서 실제 결제 금액을 계산해야 하는 주체는 어떤 애그리거트일까?
> 
> 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.
> 응용 영역의 서비스가 용용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.
> 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점은 상태 없이 로직만 구현한다.
> 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.
> 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.
> 응용 서비스와 구분을 위해 통상 응용 서비스에는 @Service 어노테이션을, 도메인 서비스에는 @Component를 사용하기도 한다.

### 팩토리
> * 복잡한 객체를 생성해야한다면 생성 역할만 책임지는 Factory 에게 그 역할을 위임할 수 있다.  
> * 도메인 객체를 생성하기 위한 기존의 클라이언트 코드가 깔끔해진다.  
> 
> 팩토리의 생성 위치  
> * 애그리거트 루트의 정적 팩토리 메서드 - 애그리거트를 생성하기 좋은 위치
> * 도메인 서비스 - 다른 애그리거트를 이용하여 생성해야한다면 고려해보자
> * 별개의 팩토리 클래스 - 구상 구현체나 생성과정의 복잡성등을 감춰야 하는 경우(?)
> Factory는 자신의 생성물과 가장 밀접한 관계에 있는 위치에 있어야 한다. (만들어내는 객체와 매우 강하게 결합돼 있으므로)

### 도메인 이벤트
> 서비스간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다.  
> 이벤트의 용도는 후처리, 데이터 동기화 등  
> 도메인 이벤트를 사용하면 애그리거트간, 바운디드 컨텍스트간, 외부 서비스와의 결합을 느슨하게 한다.(도메인 로직이 섞이는 것을 방지)  
> 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다.  
> 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생한다.  
> 스프링에서 제공하는 AbstractAggregateRoot 를 애그리거트 루트에 확장하면 애그리거트 루트 내에서 직접 이벤트를 발생할 수 있다
> (기존의 ApplicationEventPublisher을 사용하면 어플리케이션 레이어에서 이벤트를 발행해야한다)  
> 이벤트 핸들러는 서비스 레이어에서 구현하면 된다.  

---

## 설계
### 도메인 주도 설계
> 도메인 주도 설계는 크게 전략적 설계와 전술적 설계로 나뉩니다.  
> * 전략적 설계 - 도메인 전문가 및 기술팀이 함께 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고 
> 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트(bounded context)로 정의하고 경계의 관계를 컨텍스트 맵(context map)으로 정의하는 활동
> * 전술적 설계 - 전략적 설계에서 도출된 바운디드 컨텍스트와 도메인을 이용하여 애그리거트 패턴, 엔티티와 값 객체, 레포지토리 
> 등을 구성하고 구현하는 활동

### Event Storming
> 명령(Command), 애그리거트(Aggregate), 이벤트(Event) 에 대한 전체적 설계  
> 1.명령(Command) 와 그에 따라 발생하는 이벤트(Event)들의 흐름을 나열한다.  
> 2.관련있는 명령과 이벤트들을 한데 묶어 정리한다.   
> 3.묶어놓은 명령과 이벤트들을 기반으로 애그리거트를 지정한다.  
> 4.묶어놓은 명령, 이벤트 그리고 애그리거트를 바운디드 컨텍스트로 묶는다.  
> 5.개발을 진행하면서 변경되어야 하는 명령, 이벤트 또는 애그리거트가 있으면 변경한다.  

---

## 구현 아키텍처
### Layered 아키텍처
> 
> 
> 도메인 패키지의 경우 rootPackage 아래 `domain` 패키지를 만들지 않고 `<rootPackage>.<domain 명>` 로 만든다.    
> 예를 들어 rootPackage 가 `starter.ddd` 이고 주문 도메인을 만든다고 하면 `starter.ddd.order` 로 주문 도메인 패키지를
> 만들 수 있다.
>
> 도메인 패키지 안의 구조는 다음과 같다.  
> `application`: 표현 영역(Controller) 에서 사용할 응용 서비스(@Service) 들이 위치한다.
>
> `domain`: 비즈니스 로직을 담은 도메인이 위치하는 영역으로 엔티티(Entity), 저장소(Repository), 도메인 서비스가 위치한다.  
> domain 패키지 안에 클래스가 많아지면 다음과 같이 분리한다.  
> domain.model: 엔티티 및 밸류 타입을 위치한다.  
> domain.repository: 저장소가 위치한다.  
> domain.service: 도메인 서비스가 위치한다.
>
> `infra`: 도메인 서비스 구현 코드가 위치한다.
 

### Clean 아키텍처
> 

### Hexagonal 아키텍처
> 

---

## 테스트
### 단위테스트
> 

### 통합테스트
> 

---

## 이벤트

---

## Spring 에서의 DDD
### AbstractAggregateRoot
> 
